<?php


/**
 * Skeleton subclass for performing query and update operations on the 'pages' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.4.2 on:
 *
 * 09/14/13 13:02:22
 *
 * You should add additional methods to this class to meet the
 * application requirements.  This class will only be generated as
 * long as it does not already exist in the output directory.
 *
 * @package    lib.model
 */
class PagesPeer extends BasePagesPeer {
    const EXPORT_FILE_NAME = 'export_to_%s_%s.csv';
    const IMPORT_FILE_NAME = 'import_by_%s.csv';
    const SLUG_404 = '404/';
    const PROMOTIONS = 'akcii/';
    const ZAPCHASTI = 'avtozapchasti/';
    
    /**
     * Search for 1 matched record by slug (slug, old_link)
     * @param string $slug
     * @return Pages
     */
    public static  function retrieveBySlug($slug) {
        $con = Propel::getConnection();
        $q = "SELECT ".implode(', ', self::getFieldNames(BasePeer::TYPE_FIELDNAME))." FROM ".self::TABLE_NAME." WHERE ".self::SLUG." = :slug OR ".self::OLD_LINK." = :slug LIMIT 1";
        $stmt = $con->prepare($q);
        $stmt->execute(array(
            ':slug' => $slug
        ));
        $item = null;
        if ($row = $stmt->fetch(PDO::FETCH_NUM)) {
            $item = new Pages();
            $item->hydrate($row);
        }
        return $item;
    }
    
    public static function dumpExport($userId, $encoding) {
        $inc = 300;
        $con = Propel::getConnection();
        
        $sql = "SELECT ".implode(', ', self::getFieldNames(BasePeer::TYPE_FIELDNAME))." FROM ".self::TABLE_NAME." ORDER BY ".self::ID." LIMIT :from, ".$inc.";";
        $cont = true;
        $from = 0;
        $fNa = sfConfig::get('sf_cache_dir').DIRECTORY_SEPARATOR.sprintf(self::EXPORT_FILE_NAME, $userId, $encoding);
        $fh = fopen($fNa, 'w+');
        while ($cont) {
            $stmt = $con->prepare(str_replace(':from', $from, $sql));
            $stmt->execute();
            if ($stmt->rowCount() > 0) {
                fputcsv($fh, self::getFieldNames(BasePeer::TYPE_FIELDNAME), ',', '"');
                while ($row = $stmt->fetch(PDO::FETCH_NUM)) {
                    for ($i = 0; $i < count($row); $i++) {
                        if ($encoding != 'UTF-8') {
                            $row[$i] = iconv('UTF-8', $encoding.'//IGNORE', $row[$i]);
                        }
                        $row[$i] = preg_replace("/[\s]+/", " ", $row[$i]);
                    }
                    fputcsv($fh, $row, ',', '"');
                }
                $from += $inc;
            } else {
                $cont = false;
            }
            unset($stmt);
        }
        fclose($fh);
        return $fNa;
    }
    
    public static function import($tmp_file, $encoding) {
        $fh = fopen($tmp_file, 'r');
        $marks = $sets = array();
        foreach (self::getFieldNames(BasePeer::TYPE_FIELDNAME) as $field) {
            if ($field == 'id') continue;
            $marks[$field] = ':'.$field;
            if ($field != 'created_at')
                $sets[] = $field.' = :'.$field;
        }
        $sql = "INSERT INTO ".self::TABLE_NAME."(".implode(', ', array_keys($marks)).") VALUES(".implode(', ', $marks).") ON DUPLICATE KEY UPDATE ".implode(', ', $sets).";";
        $con = Propel::getConnection();
        $stmt = $con->prepare($sql);
        
        $report = array(
            'errorLines' => array(),
            'worked' => 0,
            'success' => true
        );
        $i = 0;
        while (!feof($fh)) {
            $row = fgetcsv($fh);
            if ($i == 0) {
                $i++;
                continue;
            }
            if (!$row && feof($fh)) continue;
            
            if (!$row) {
                $report['success'] = false;
                $report['errorLines'][] = $i;
                continue;
            }
            
            $mapped = array();
            foreach (self::getFieldNames(BasePeer::TYPE_FIELDNAME) as $key => $field) {
                if ($key == 0) continue;
                $mapped[':'.$field] = (isset($row[$key])) ? (($encoding != 'UTF-8')?iconv($encoding, 'UTF-8//IGNORE', $row[$key]):$row[$key]): null;
            }
            $mapped[':is_301redirect'] = (int)$mapped[':is_301redirect'];
            if (empty($mapped[':old_link'])) {
                $mapped[':old_link'] = null;
            } else {
                $mapped[':old_link'] = '/'.preg_replace("/^\/*/", '', $mapped[':old_link']);
                $mapped[':old_link'] = preg_replace("/\/*$/", '', $mapped[':old_link']).'/';
            }
            if (empty($mapped[':slug'])) {
                $mapped[':slug'] = null;
            } else {
                $mapped[':slug'] = '/'.preg_replace("/^\/*/", '', $mapped[':slug']);
                $mapped[':slug'] = preg_replace("/\/*$/", '', $mapped[':slug']).'/';
            }
            if (empty($mapped[':created_at'])) $mapped[':created_at'] = date("Y-m-d H:i:s");
            $mapped[':updated_at'] = date("Y-m-d H:i:s");
            
            $success = true;
            try {
                $stmt->execute($mapped);
            } catch (Exception $e) {
                $success = false;
            }

            if (!$success) {
                $report['success'] = false;
                $report['errorLines'][] = $i;
            } else {
                $report['worked']++;
            }
            $i++;
        }
        fclose($fh);
        
        return $report;
    }
} // PagesPeer
